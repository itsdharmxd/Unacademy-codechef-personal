{
  "basic template": {
        "prefix": "d_basic",
        "body": [
            "",
            "#include <bits/stdc++.h>",
            "using namespace std;",
            "#define ll long long",
            "#define rep(a, b, c) for (ll a = b; a < c; a++)",
            "#define repr(a, b, c) for (ll a = b; a >= c; a--)",
            "#define fst first",
            "#define snd second",
            "#define pb push_back",
            "#define pii  pair<ll,ll>",
            "#define vi   vector<ll>",
            "#define all(c) ((c).begin()), ((c).end())",
            "#define test()                        \\",
            "    freopen(\"input.txt\", \"r\", stdin); \\",
            "    freopen(\"output.txt\", \"w\", stdout);",
            "#define fast()                    \\",
            "    ios_base::sync_with_stdio(0); \\",
            "    cin.tie(0);                   \\",
            "    cout.tie(0);",
            "#define LOG2(X) ((unsigned)(8 * sizeof(unsigned long long) - __builtin_clzll((unsigned long long)(X)) - 1))",
            "",
            "",
            "",
            "int solve()",
            "{",
            "    ",
            " ",
            "",
            "",
            "    return 0;",
            "}",
            "",
            "int main()",
            "{",
            "#ifndef ONLINE_JUDGE",
            "    test()",
            "#endif // !ONLINE_JUDGE",
            "        int t = 1;",
            "    //cin >> t;",
            "",
            "    while (t--)",
            "    {",
            "        solve();",
            "    }",
            "    return 0;",
            "}"
        ],
        "description": "basic template"
    },
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    "prime_in_range": {
        "prefix": "d_primerange",
        "body": [
            "vector<ll> primes(ll lo, ll hi)",
            "{ // primes in [lo, hi)",
            "const ll M = 1 << 14, SQR = 1 << 16;",
            "vector<bool> composite(M), small_composite(SQR);",
            "vector<pair<ll, ll>> sieve;",
            "for (ll i = 3; i < SQR; i += 2)",
            "{",
            "    if (!small_composite[i])",
            "    { ll k = i * i + 2 * i * max(0.0, ceil((lo - i * i) / (2.0 * i)));",
            "      sieve.push_back({2 * i, k});",
            "      for (ll j = i * i; j < SQR; j += 2 * i)",
            "            small_composite[j] = 1;",
            "    }",
            "}",
            " vector<ll> ps;",
            "if (lo <= 2)",
            "{",
            "ps.push_back(2);",
            "lo = 3;",
            " }",
            "for (ll k = lo | 1, low = lo; low < hi; low += M)",
            "{",
            "ll high = min(low + M, hi);",
            "fill(all(composite), 0);",
            "for (auto &z : sieve)",
            " for (; z.snd < high; z.snd += z.fst)",
            "         composite[z.snd - low] = 1;",
            " for (; k < high; k += 2)",
            " if (!composite[k - low])",
            "     ps.push_back(k);",
            "    }",
            "    return ps;",
            "}"
        ],
        "description": "prime_in_range"
    },
  
    "power_mod": {
        "prefix": "d_mpow",
        "body": [
            "int mpow(int base, int exp)",
            "{",
            "    int result = 1;",
            "    while (exp > 0)",
            "    {",
            "        if (exp & 1)",
            "            result = ((long long)result * base) % mod;",
            "        base = ((long long)base * base) % mod;",
            "        exp >>= 1;",
            "    }",
            "    return result;",
            "}"
        ],
        "description": "power_mod"
    },
 "NCR": {
    "prefix": "d_ncr",
    "body": [
        "",
        "const int ncr_mod = 1e9 + 7;",
        "const int ncr_N = 1e6;",
        "ll fac[ncr_N], inv[ncr_N], b[ncr_N];",
        "",
        "",
        "void pre()// must run pre function before use",
        "{",
        "   int i;",
        "    fac[0]  = 1;",
        "    fac[1]  = 1;",
        "",
        "    for (i = 2; i < ncr_N;i++)",
        "    {",
        "        fac[i] = (i * fac[i - 1]) % ncr_mod;",
        "        // mod power",
        "    }",
        "    i--;",
        "    inv[i] = mpow(fac[i], ncr_mod - 2);",
        "",
        "    for (i--; i >= 0;i--){",
        "        inv[i] = (inv[i + 1] * (i + 1)) % ncr_mod;",
        "    }",
        "}",
        "ll C(int n, int r)",
        "{",
        "    if (r > n)",
        "        return 0;",
        "    ll ans = fac[n];",
        "    ans *= inv[r];",
        "    ans %= ncr_mod;",
        "    ans *= inv[n - r];",
        "    ans %= ncr_mod;",
        "    return ans;",
        "}",
        "ll P(int n, int r)",
        "{",
        "    if (r > n)",
        "        return 0;",
        "    ll ans = fac[n];",
        "    ans *= inv[n - r];",
        "    ans %= ncr_mod;",
        "    return ans;",
        "}"
    ],
    "description": "NCR"
},
"Z function": {
    "prefix": "d_zfunction",
    "body": [
        "vector<int> z_function(string s){",
        "    int n = s.size();",
        "    vector<int> z(n,0);",
        "",
        "    for (int i = 1,l=0,r=0; i < n;i++){",
        "",
        "        if(i<=r){",
        "            z[i] = min(z[i - l], r - i + 1);",
        "        }",
        " ",
        "",
        "        while (i + z[i] < n&&s[i+z[i]]==s[z[i]])",
        "            z[i]++;      ",
        "",
        "       if(i+z[i]-1>r){",
        "           l = i,r=i+z[i]-1;",
        "       }    ",
        "",
        "    }",
        "",
        "    return z;",
        "",
        "}"
    ],
    "description": "Z function"
},
"KMP prefix lps": {
    "prefix": "d_prefixlps",
    "body": [
        "vector<int> prefix_lps(string s){",
        "    int n = s.size();",
        "    vector<int> lps(n);",
        "    lps[0] = 0;",
        "    int i = 1,len=0;",
        "    while (i<n)",
        "    {",
        "      if(s[i]==s[len]){",
        "          len++;",
        "          lps[i] = len;",
        "          i++;",
        "      }else{",
        "        if(len!=0){",
        "            len = lps[len-1];",
        "        }else{",
        "            lps[i] = len;",
        "            i++;",
        "        }",
        "  ",
        "",
        "      }",
        "",
        "    }",
        "",
        "    return lps;",
        "",
        "}"
    ],
    "description": "KMP prefix lps"
},
"test with file": {
    "prefix": "d_test",
    "body": [
        "freopen(\"input.txt\", \"r\", stdin);freopen(\"output.txt\", \"w\", stdout);"
    ],
    "description": "test with file"
},
"palindrom of odd even points": {
    "prefix": "d_palindrom_manacher",
    "body": [
        "pair<vector<int>,vector<int>> manacher(string str){",
        "  int n = str.size();",
        "  vector<int> odd(n,1),even(n,0);",
        "",
        "  for (int i = 0,l=0,r=-1; i < n;i++){",
        " ",
        "    if(i<=r){",
        "      odd[i] = min(r-i+1,odd[l+(r-i)]);",
        "    }",
        "",
        "    while (((i+odd[i])<n&&((i-odd[i]>=0)))&&str[i+odd[i]]==str[i-odd[i]])",
        "    {",
        "    ",
        "",
        "      odd[i]++;",
        "    }",
        "  ",
        "    if(i+odd[i]-1>r){",
        "      r = i + odd[i] - 1;",
        "      l = i - odd[i] + 1;",
        "    }",
        "",
        "    ",
        "",
        "  }",
        "",
        "  for (int i = 1,l=0,r=-1; i < n;i++){",
        "    ",
        "   if(i<=r){",
        "     even[i] = min(r - i+1,even[l+(r-i)+1] );",
        "   }",
        "",
        "",
        "    while (((i - even[i] - 1)>=0)&&((i+even[i])<n) && str[i - even[i] - 1] == str[i + even[i]])",
        "    {",
        "      even[i]++;",
        "   }",
        "     ",
        "  if(i+even[i]>r){",
        "    r = i + even[i] -1;",
        "  l = i - even[i];}",
        "  }",
        "",
        "    return make_pair(even,odd);",
        "}"
    ],
    "description": "palindrom of odd even points"
},
"Modular NOte": {
    "prefix": "d_mod_note",
    "body": [
        "",
        "//add  (a+b)%c   =>   (a%c + b%c)%c",
        "",
        "//mul (a*b)%c   =>   (a%c * b%c)%c",
        "",
        "//sub (a-b)%c   =>   (a%c - b%c +c)%c",
        "",
        "/*",
        "dividee",
        "",
        "(a/b)%c",
        "",
        "if  b c  are coprime ",
        "",
        "b inverse = b^c-2",
        "",
        "(a%c * b_inverse %c)%ca ",
        "   ",
        "",
        "",
        "*/",
        ""
    ],
    "description": "Modular NOte"
},
"dijkstra": {
    "prefix": "d_dijkstra",
    "body": [
        "void dijkstra(vector<pair<int,int>>graph[],int vertex,int src){",
        " ",
        "   priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;",
        "   vector<int> dist(vertex+1, INT_MAX),parent(vertex+1,-1);",
        "  // if multi source then do this for all src nodes below 2 lines",
        "   dist[src] = 0;",
        "   parent[src] = -1;",
        " ",
        "   pq.push({0, src});",
        " ",
        "   while (!pq.empty())",
        "   {",
        "      int u = pq.top().second;",
        "      pq.pop();",
        "     ",
        "      for(auto i:graph[u]){",
        "         int v = i.first;",
        "         int weight = i.second; ",
        " ",
        "         if(dist[v]>dist[u]+weight){",
        "            dist[v] = dist[u] + weight;",
        "            pq.push({dist[v],v});",
        "            parent[v] = u;",
        "         }   ",
        "     ",
        " ",
        " ",
        "      } ",
        "      ",
        "       ",
        "   }",
        "   if(parent[vertex]==-1){",
        "      cout << \"IMPOSSIBLE\" << endl;",
        "      return ;",
        "   }",
        "  ",
        " ",
        "   cout << dist[vertex] + 1 << endl;",
        "   vector<int> ans;",
        "   int pare = vertex;",
        " ",
        "   while (pare != -1)",
        "   {",
        "      ans.push_back(pare);",
        "      pare = parent[pare];",
        "    }",
        " ",
        "    reverse(ans.begin(), ans.end());",
        " ",
        "    rep(i,0,ans.size()){",
        "       cout << ans[i] << \" \";",
        "    }",
        " ",
        " ",
        " ",
        "}"
    ],
    "description": "dijkstra"
},
"bellman ford": {
    "prefix": "d_bellmanford",
    "body": [
        "void bellman_ford(vector<pair<int, pii>> graph, int vertex, int src)",
        "{",
        "",
        "    vi dist(vertex, INT_MAX),cost(vertex,INT_MAX);",
        "    dist[src] = 0;",
        "    cost[src] = 0;",
        "",
        "    bool update=false;",
        "    rep(i, 0, vertex - 1)",
        "    {",
        "        update = false;",
        "        for (auto edge : graph)",
        "        {",
        "            int u = edge.first;",
        "            int v = edge.second.first;",
        "            int weight = edge.second.second;",
        "",
        "            if (dist[u] != INT_MAX && dist[v] > dist[u] + weight)",
        "            {",
        "                dist[v] = dist[u] + weight;",
        "                update = true;",
        "                cost[v] = dist[v];",
        "            }",
        "",
        "",
        "       }",
        "          if(!update){",
        "              break;",
        "          }",
        "    }",
        "    if(update)",
        "    for(auto edge:graph){",
        "        int u = edge.first;",
        "        int v = edge.second.first;",
        "        int weight = edge.second.second;",
        "",
        "        if(dist[u]!=INT_MAX && dist[v]>dist[u]+weight){",
        "            cout << \"negative edge\" << endl;",
        "            return;",
        "        }",
        "",
        "",
        "    }",
        "",
        "    rep(i,0,dist.size()){",
        "        cout << i << \" \" << dist[i]<<endl;",
        "",
        "    }",
        " ",
        " ",
        "",
        "}"
    ],
    "description": "bellman ford"
},
"floyed warshall": {
    "prefix": "d_floyedwarshall",
    "body": [
        "void floyd_warshall(vector<pair<int, pii>> graph,int vertex){",
        "",
        "    vector<vi> dist(vertex + 1, vi(vertex + 1, INT_MAX));",
        "",
        "    rep(i,1,vertex+1){",
        "        dist[i][i] = 0;",
        "    }",
        "",
        "    for(auto e:graph){",
        "        dist[e.first][e.second.first] = e.second.second;",
        "    }",
        "",
        "    rep(k, 1, vertex + 1)",
        "        rep(i, 1, vertex + 1)",
        "            rep(j, 1, vertex + 1) if (dist[i][k] < INT_MAX && dist[k][j] < INT_MAX)",
        "                dist[i][j] = min(dist[i][j],dist[i][k]+dist[k][j]);",
        "",
        "",
        "// for negative edge",
        "    rep(k, 1, vertex + 1)",
        "        rep(i, 1, vertex + 1)",
        "            rep(j, 1, vertex + 1) ",
        "            if(dist[i][k]<INT_MAX and dist[k][k]<0 && dist[k][j]<INT_MAX )",
        "            {  // if found",
        "                dist[i][j] = INT_MIN;",
        "                return;",
        "            } ",
        "             ",
        "              ",
        "             ",
        "            }"
    ],
    "description": "floyed warshall"
}
,
"sparse table ": {
    "prefix": "d_sparsetable",
    "body": [
        "template <class T>",
        "struct sparse_table",
        "{",
        "    const vector<T> &x;",
        "    vector<vector<int>> table;",
        "    int argmin(int i, int j) { return x[i] > x[j] ? i : j; }",
        "    sparse_table(const vector<T> &x) : x(x)",
        "    {",
        "        int logn = sizeof(int) * __CHAR_BIT__ - 1 - __builtin_clz(x.size());",
        "        table.assign(logn + 1, vector<int>(x.size()));",
        "        iota(all(table[0]), 0);",
        "        for (int h = 0; h + 1 <= logn; ++h)",
        "            for (int i = 0; i + (1 << h) < x.size(); ++i)",
        "                table[h + 1][i] = argmin(table[h][i], table[h][i + (1 << h)]);",
        "    }",
        "    T range_min(int i, int j)",
        "    {",
        "        j++;                                                           // = min x[i,j)",
        "        int h = sizeof(int) * __CHAR_BIT__ - 1 - __builtin_clz(j - i); // = log2",
        "        return x[argmin(table[h][i], table[h][j - (1 << h)])];",
        "    }",
        "};"
    ],
    "description": "sparse table "
},
"tree rerooting": {
    "prefix": "d_rerooting",
    "body": [
        "const int M = 2e5+20, N = 2 * M;",
        "",
        "int U[N], V[N], W[N], pos[N];",
        "vector<int> g[M], vis(M, 0), value(N, 0);",
        "vector<int> prefix[M], suffix[M];",
        "",
        "int vtz(vector<int> &v, int idx) // value to xero",
        "{",
        "if (idx < v.size() && idx >= 0)",
        "return v[idx];",
        "return 0;",
        "}",
        "void prefix_suffix(int node)",
        "{",
      "int n = g[node].size();",
    "prefix[node].resize(n);",
    "suffix[node].resize(n);",
        "",
    "for (int i = 0, j = n - 1; i < n; i++, j--)",
    "{",
    "prefix[node][i] = max(vtz(prefix[node], i - 1) ,value[g[node][i]]);",
    "suffix[node][j] = max(vtz(suffix[node], j + 1) , value[g[node][j]]);",
    "}",
        "}",
        "void dfs(int node, int par)",
        "{   ",
    "if (!vis[node])",
    "{",
    "",
    "vis[node] = par ^ 1;",
    "for (auto v : g[node])",
    "{",
    "if (v != vis[node])",
    "dfs(V[v], v);",
    "}",
    "prefix_suffix(node);",
    "}",
    "else if (1 < vis[node])",
    "{",
    "",
        "",
    "dfs(V[vis[node]], vis[node]);",
    "vis[node] = 1;",
    "prefix_suffix(node);",
    "}",
    "if (par)",
    "{",
    "",
    "int idx = pos[par ^ 1];",
    "value[par] = max(vtz(prefix[node], idx - 1) , vtz(suffix[node], idx + 1) )+ W[par];",
    "}",
        "}",
        "void addedge(int e, int u, int v, int w)",
        "{",
        "",
    "U[e] = u;",
    "V[e] = v;",
    "W[e] = w;",
    "pos[e] = g[u].size();",
    "g[u].pb(e);",
        "}",
        ""
    ],
    "description": "tree rerooting"
},
"LCA Binary lifting": {
    "prefix": "d_lca",
    "body": [
        "const int N = 2e5+100, L = LOG2(N) + 2;",
        "",
        " int parent[L][N];",
        "vector<int> tree[N], height(N, 0);",
        "void pre(int node, int par)",
        "{",
        "parent[0][node] = par;",
            "",
        "height[node] = height[par] + 1;",
        "for (int child : tree[node])",
        "{",
        "if (child != par)",
        "{",
        "pre(child, node);",
        "}",
        "}",
        "}",
        "void sparcepre(int n)",
        "{ // pre ->",
    "pre(1, 0);",
    "for (int k = 1; k < L; k++)",
    "{",
    "for (int i = 1; i <= n; i++)",
    "{",
    "if (parent[k - 1][i] != 0)",
    "parent[k][i] = parent[k - 1][parent[k - 1][i]];",
    "}",
    "}",
        "}",
        "int k_ansestor(int node, int k)",
        "{",
    "int curr = node;",
    "int b = 0;",
    "while (k)",
    "{",
    "if (k & 1)",
    "curr = parent[b][curr];",
    "b++;",
    "k = k >> 1;",
    "}",
    "return curr;",
        "}",
        "int LCA(int u, int v)",
        "{",
    "if (height[u] < height[v])",
    "swap(u, v);",
    "u = k_ansestor(u, height[u] - height[v]);",
    "if (u == v)",
    "return u;",
    "for (int k = L - 1; k >= 0; k--)",
    "{",
    "if (parent[k][u] != parent[k][v])",
    "{",
    "u = parent[k][u];",
    "v = parent[k][v];",
    "}",
    "}",
    "return parent[0][u];",
        "}"
    ],
    "description": "LCA Binary lifting"
},
"spf segmentedseive": {
    "prefix": "d_spf_segmentedseive",
    "body": [
        "const int N = 1000000;",
        " ll spf[N+1];",
        "",
        "void prespf(){",
        "     for(ll i=2;i<=N;i++){",
        "     if(!spf[i]){",
        "spf[i] = i;",
        "for (ll j = i * i; j <=N; j += i){",
        "",
        "if(!spf[j])",
        "spf[j] = i;",
        "}",
        "}",
        "}",
            "}",
        "",
        "vector<pii> getfactors(int x){",
    "vector<pii> ans;",
        "  while (x>1)",
        "  {",
    "int p = spf[x];",
    " int c = 0;",
        " ",
        "     while (!(x%p))",
    "{",
    " x /= p;",
    " c++;",
    " }",
    " ans.pb({p, c});",
        "  }",
    "return ans;",
        "}",
        "vi segmentedseive(ll l, ll r){",
        "   if(l==1)",
    "   l++;",
        "   vector<ll> primes(r - l + 1,1);",
        "",
        "   for (ll i = 2; i * i <= r; i++)",
        "   {",
    "   ll num = i * ((l + i - 1) / i);",
        "",
    "   for (ll j = max(i * i, num); j <= r;j+=i){",
    "   primes[j - l] = 0;",
    "   }",
        "   }",
        "   vector<ll> ans;",
        "   for (ll i = 0; i < primes.size(); i++)",
        "   {",
        "          if(primes[i])",
    "  ans.pb(i + l);",
        "   }",
        "   return ans;",
        "}",
        ""
    ],
    "description": "spf segmentedseive"
},
"extended excluid algo": {
    "prefix": "d_extended_excluid",
    "body": [
        "pii extended_ecluid(ll a, ll b)",
        "{ //a>b",
        "    if (b == 0)",
        "    {",
        "        return {1, 0};",
        "    }",
        "    pii k = extended_ecluid(b, a % b);",
        "    ll x = k.first, y = k.second;",
        "    return {y, x - (a / b) * y};",
        "}"
    ],
    "description": "extended excluid algo"
},"Genetic segment tree": {
  "prefix": "d_segtree",
  "body": [
    "",
    "const int INF = 1e9;",
    "const int mod = 1e9+7;",
    "//associaltive opeation",
    "struct my_node",
    "{ // value on main treee node",
    "   ll value =0;  //1",
    "",
    "   my_node() {}",
    "   my_node(ll val)",
    "   { /// for leaf node direct initialize",
    "   value = val;  //2",
    "   }",
    "   void merge(const my_node &l, const my_node &r)",
    "   {",
    "    //left , right subtree to current node",
    "    value = l.value + r.value;//3",
    "  }",
    "};",
    "",
    "struct my_update",
    "{",
    "  ll v = 0; // 4",
    "  my_update() {}",
    "  my_update(ll val)",
    "  {",
    "   v = val; // 5",
    "  }",
    "  void combine(my_update &other, const int32_t &tl, const int32_t &tr)",
    "  {",
    "   // New Update for range (other==new)",
    "   v+= other.v;   //6",
    "  } ",
    "  // store the correct information in the my_node x",
    "  void apply(my_node &x, const int32_t &tl, const int32_t &tr)",
    "  { // apply update to the node tree",
    "",
    "     x.value += (tr - tl + 1) * v; // 7",
    "  }",
    "};",
    "",
    "template <typename node, typename update>",
    "struct segtree",
    "{ private:",
    "   int len;",
    "   vector<node> t;",
    "  vector<update> u;",
    "  vector<bool> lazy;",
    "  node identity_element;",
    "   update identity_transformation;",
    "  public: ",
    "   segtree(int l)",
    "   {",
    "  len = l;",
    "  t.resize(4 * len);",
    "   u.resize(4 * len);",
    "  lazy.resize(4 * len);",
    "  identity_element = node();",
    "  identity_transformation = update();",
    "  }",
    "  private:",
    "",
    "  void pushdown(const int32_t &v, const int32_t &tl, const int32_t &tr)",
    "   {",
    "   if (!lazy[v])",
    "    return;",
    "   int32_t tm = (tl + tr) >> 1;",
    "    apply(v << 1, tl, tm, u[v]);",
    "   apply(v << 1 | 1, tm + 1, tr, u[v]);",
    "   u[v] = identity_transformation;",
    "   lazy[v] = 0;",
    "   }",
    "",
    "   void apply(const int32_t &v, const int32_t &tl, const int32_t &tr, update upd)",
    "  {",
    "   if (tl != tr)",
    "   {",
    "   lazy[v] = 1;",
    "   u[v].combine(upd, tl, tr);",
    "   }",
    "  upd.apply(t[v], tl, tr);",
    "  }",
    "",
    "   template <typename T>",
    "   void build(const T &arr, const int32_t &v, const int32_t &tl, const int32_t &tr)",
    "  {",
    "   if (tl == tr)",
    "   {",
    "   t[v] = arr[tl];",
    "  return;",
    "   }",
    "   int32_t tm = (tl + tr) >> 1;",
    "    build(arr, v << 1, tl, tm);",
    "   build(arr, v << 1 | 1, tm + 1, tr);",
    "   t[v].merge(t[v << 1], t[v << 1 | 1]);",
    "   }",
    "",
    "  node query(const int32_t &v, const int32_t &tl, const int32_t &tr, const int32_t &l, const int32_t &r)",
    "  {",
    "   if (l > tr || r < tl)",
    "   {",
    "   return identity_element;",
    "   }",
    "   if (tl >= l && tr <= r)",
    "   {",
    "   return t[v];",
    "   }",
    "   pushdown(v, tl, tr);",
    "   int32_t tm = (tl + tr) >> 1;",
    "   node a = query(v << 1, tl, tm, l, r), b = query(v << 1 | 1, tm + 1, tr, l, r), ans;",
    "   ans.merge(a, b);",
    "   return ans;",
    "  }",
    "",
    "   // rupd = range update",
    "   void rupd(const int32_t &v, const int32_t &tl, const int32_t &tr, const int32_t &l, const int32_t &r, const update &upd)",
    "   {",
    "  if (l > tr || r < tl)",
    "   {",
    "  return;",
    "   }",
    "   if (tl >= l && tr <= r)",
    "   {",
    "   apply(v, tl, tr, upd);",
    "   return;",
    "   }",
    "   pushdown(v, tl, tr);",
    "   int32_t tm = (tl + tr) >> 1;",
    "   rupd(v << 1, tl, tm, l, r, upd);",
    "   rupd(v << 1 | 1, tm + 1, tr, l, r, upd);",
    "   t[v].merge(t[v << 1], t[v << 1 | 1]);",
    "   }",
    "",
    "public:",
    "  template <typename T>",
    "  void build(const T &arr)",
    "  {",
    "  build(arr, 1, 0, len - 1);",
    "   }",
    "   node query(const int32_t &l, const int32_t &r)",
    "  {",
    "  return query(1, 0, len - 1, l, r);",
    "   }",
    "   void rupd(const int32_t &l, const int32_t &r, const update &upd)",
    "  {",
    "   rupd(1, 0, len - 1, l, r, upd);",
    "   }",
    "};",
    "// segtree<my_node, my_update> st(n);",
    "// st.build(a);",
    "// st.rupd(l, r, v);",
    "// st.query(l, r).value",
    ""
  ],
  "description": "Genetic segment tree"
},

"Kosaraju strongly connected ": {
  "prefix": "d_stronglyconnectedKosaraju",
  "body": [
    "//set N for no  of nodes",
    "int N = 100000;",
    "int n,m;",
    "vector<vector<int>> adj(N), rev(N),cg_adj;",
    "vector<int> ssc_no(N,0);",
    "void dfs(int i ,vector<int> &vis,vector<int>&vals){",
    "  if(vis[i]==1)",
    "   return;",
    "   vis[i] = 1;",
    "    for(int j:adj[i])",
    "    {",
    "       if(!vis[j]){",
    "         dfs(j, vis, vals);",
    "    }",
    "    }",
    "    vals.push_back(i);",
    "}",
    "",
    "void rev_dfs(int i,int num){",
    "    ssc_no[i] = num;",
    "    for(int j:rev[i]){",
    "         if(!ssc_no[j]){",
    "           rev_dfs(j, num);",
    "        }",
    "     }",
    "}",
    "",
    "int condensationgraph(){",
    "     vector<int> vis(n + 1), vals;",
    "      for (int i = 1; i <= n; i++){  ",
    "       if(!vis[i]){",
    "         dfs(i, vis, vals);",
    "       }",
    "     }",
    "   reverse(vals.begin(), vals.end());",
    "   int num = 1;",
    "     for(int i:vals){",
    "      if(!ssc_no[i]){",
    "           rev_dfs(i, num);",
    "           num++;",
    "       }",
    "     }",
    "cg_adj.resize(num);",
    "for (int i = 1; i <= n;i++){",
    "for(int j:adj[i]){",
    "if(ssc_no[i]!=ssc_no[j]){",
    "cg_adj[ssc_no[i]].push_back(ssc_no[j]);",
    "}",
    "}",
    "}",
    "return num - 1;",
    "}",
    "// cin >> n >> m;",
    "// while (m--)",
    "// {",
    "//     int u, v;",
    "//     cin >> u >> v;",
    "//     adj[u].push_back(v);",
    "//    rev[v].push_back(u);",
    "// }",
    "// int sccs = condensationgraph();",
    "// for (int i = 1; i <= n; i++)",
    "// {",
    "//     cout << i << \" \" << ssc_no[i] << endl;",
    "// }",
    "// cout << endl;",
    "// for (int i = 1; i <= sccs; i++)",
    "// {",
    "//      for (int j : cg_adj[i])",
    "//      cout << i << \" \" << j << endl;",
    "// }"
  ],
  "description": "Kosaraju strongly connected "
},
"Data Structure Union": {
  "prefix": "d_DSU",
  "body": [
    "struct DSU",
    "{",
    " int connected;",
    " vector<int> par, sz;",
    "",
    " void init(int n) ",
    " {",
    " par = sz = vector<int> (n + 1, 0);",
    " for(int i = 1; i <= n; i++)",
    " par[i] = i, sz[i] = 1;",
    " connected = n;",
    " }",
    "",
    " int getPar(int u)",
    " {",
    " while(u != par[u])",
    " {",
    " par[u] = par[par[u]];",
    " u = par[u];",
    " }",
    " return u;",
    " }",
    "",
    " int getSize(int u)",
    " {",
    " return sz[getPar(u)];",
    " }",
    "",
    " void unite(int u, int v)",
    " {",
    " int par1 = getPar(u), par2 = getPar(v);",
    "",
    " if(par1 == par2)",
    " return;",
    "",
    " connected--;",
    "",
    " if(sz[par1] > sz[par2])",
    " swap(par1, par2);",
    "",
    " sz[par2] += sz[par1];",
    " sz[par1] = 0;",
    " par[par1] = par[par2];",
    " }",
    "};",
    "// vector<int> arr{1, 2, 3, 4, 5};",
    "// struct DSU dsu;",
    "// dsu.init(arr.size());",
    "// dsu.unite(1, 2);"
  ],
  "description": "Data Structure Union"
}





}